Alterações feitas no arquivo original do laboratório 2:

Posição inicial da câmera alterada para dentro do labirinto

glm::vec4 g_CameraPosition     = glm::vec4(-4.0f, 0.0f, -4.0f, 1.0f); // Posição inicial da câmera
glm::vec4 g_CameraViewVector   = glm::vec4(0.0f, 0.0f, -1.0f, 0.0f); // Vetor "view", para onde a câmera está virada
glm::vec4 g_CameraUpVector     = glm::vec4(0.0f, 1.0f, 0.0f, 0.0f); // Vetor "up"

Definição do mapa do labirinto

 // 0 = espaço vazio, 1 = parede 
 const int map_width = 10;
 const int map_height = 10;
 int maze_map[map_height][map_width] = {
        {1,1,1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,0,0,1},
        {1,0,1,1,0,1,1,1,0,1},
        {1,0,1,0,0,0,1,0,0,1},
        {1,0,1,0,1,0,1,0,1,1},
        {1,0,0,0,1,0,0,0,0,1},
        {1,1,1,1,1,0,1,1,0,1},
        {1,0,0,0,0,0,0,1,0,1},
        {1,0,1,1,1,1,0,0,0,1},
        {1,1,1,1,1,1,1,1,1,1}
};

Desenha o chão
      {
            glm::mat4 model = Matrix_Identity();
            the_model = model; // Salva para o texto

            glUniformMatrix4fv(model_uniform, 1, GL_FALSE, glm::value_ptr(model));
            glUniform1i(render_as_black_uniform, false);

            glDrawElements(
                g_VirtualScene["floor"].rendering_mode,
                g_VirtualScene["floor"].num_indices,
                GL_UNSIGNED_INT,
                (void*)g_VirtualScene["floor"].first_index
            );
        }

Desenha o labirinto com base no maze_map
      // (Substitui o loop for (int i = 1; i <= 3; ++i))
        for (int z = 0; z < map_height; ++z)
        {
            for (int x = 0; x < map_width; ++x)
            {
                // Se for uma parede (1)
                if (maze_map[z][x] == 1)
                {
                    // Os cubos têm 1x1x1, e eles vão de -0.5 até 0.5                             
                    // Calcula a posição no mundo, centrando o labirinto em (0,0)

                    float pos_x = (float)x - (float)map_width / 2.0f;
                    float pos_z = (float)z - (float)map_height / 2.0f;

                    glm::mat4 model = Matrix_Translate(pos_x, 0.0f, pos_z);

                    // Envia a matriz "model" para a placa de vídeo (GPU).
                    glUniformMatrix4fv(model_uniform, 1, GL_FALSE, glm::value_ptr(model));

                    // Desenha as faces coloridas
                    glUniform1i(render_as_black_uniform, false);
                    glDrawElements(
                        g_VirtualScene["cube_faces"].rendering_mode,
                        g_VirtualScene["cube_faces"].num_indices,
                        GL_UNSIGNED_INT,
                        (void*)g_VirtualScene["cube_faces"].first_index
                    );

                    // Desenha as arestas pretas
                    glLineWidth(4.0f);
                    glUniform1i(render_as_black_uniform, true);
                    glDrawElements(
                        g_VirtualScene["cube_edges"].rendering_mode,
                        g_VirtualScene["cube_edges"].num_indices,
                        GL_UNSIGNED_INT,
                        (void*)g_VirtualScene["cube_edges"].first_index
                    );
                }
            }
        }

Desenha a picareta
        {
            // Limpa o Z-buffer para garantir que a picareta sempre apareça na frente
            glClear(GL_DEPTH_BUFFER_BIT);

            // Usamos uma matriz View identidade para desenhar em "Camera Space"
            glm::mat4 pickaxe_view = Matrix_Identity();
            glUniformMatrix4fv(view_uniform, 1, GL_FALSE, glm::value_ptr(pickaxe_view));

            // Modelo do Cabo da Picareta
            glm::mat4 handle_model = Matrix_Translate(0.4f, -0.3f, -1.0f) // Posição na tela
                                   * Matrix_Rotate_Z(glm::radians(-30.0f)) // Rotação
                                   * Matrix_Scale(0.08f, 0.6f, 0.08f);    // Tamanho (fino e longo)
            
            glUniformMatrix4fv(model_uniform, 1, GL_FALSE, glm::value_ptr(handle_model));
            
            // Desenha faces do cabo
            glUniform1i(render_as_black_uniform, false);
            glDrawElements(
                g_VirtualScene["cube_faces"].rendering_mode,
                g_VirtualScene["cube_faces"].num_indices,
                GL_UNSIGNED_INT,
                (void*)g_VirtualScene["cube_faces"].first_index
            );
            // Desenha arestas do cabo
            glUniform1i(render_as_black_uniform, true);
            glDrawElements(
                g_VirtualScene["cube_edges"].rendering_mode,
                g_VirtualScene["cube_edges"].num_indices,
                GL_UNSIGNED_INT,
                (void*)g_VirtualScene["cube_edges"].first_index
            );

            // Modelo da Cabeça da Picareta
            glm::mat4 head_model = Matrix_Translate(0.4f, -0.3f, -1.0f)      // Mesma Posição
                                 * Matrix_Rotate_Z(glm::radians(-30.0f))    // Mesma Rotação
                                 * Matrix_Translate(0.0f, 0.25f, 0.0f)      // Desloca para a ponta do cabo
                                 * Matrix_Scale(0.3f, 0.08f, 0.08f);       // Tamanho (largo e fino)

            glUniformMatrix4fv(model_uniform, 1, GL_FALSE, glm::value_ptr(head_model));
            
            // Desenha faces da cabeça
            glUniform1i(render_as_black_uniform, false);
            glDrawElements(
                g_VirtualScene["cube_faces"].rendering_mode,
                g_VirtualScene["cube_faces"].num_indices,
                GL_UNSIGNED_INT,
                (void*)g_VirtualScene["cube_faces"].first_index
            );
            // Desenha arestas da cabeça
            glUniform1i(render_as_black_uniform, true);
            glDrawElements(
                g_VirtualScene["cube_edges"].rendering_mode,
                g_VirtualScene["cube_edges"].num_indices,
                GL_UNSIGNED_INT,
                (void*)g_VirtualScene["cube_edges"].first_index
            );
        }

Vértices para o chão (y = -0.5)
     //    X      Y     Z     W
      -50.0f, -0.5f, -50.0f, 1.0f, // vértice 14
       50.0f, -0.5f, -50.0f, 1.0f, // vértice 15
       50.0f, -0.5f,  50.0f, 1.0f, // vértice 16
      -50.0f, -0.5f,  50.0f, 1.0f  // vértice 17

Cores para o chão (verde)
      0.3f, 0.7f, 0.2f, 1.0f, // cor do vértice 14
        0.3f, 0.7f, 0.2f, 1.0f, // cor do vértice 15
        0.3f, 0.7f, 0.2f, 1.0f, // cor do vértice 16
        0.3f, 0.7f, 0.2f, 1.0f  // cor do vértice 17

Definimos os índices para as FACES do chão
14, 15, 16, // triângulo 1 (chão)
14, 16, 17, // triângulo 2 (chão)


Criamos um objeto para o chão
   SceneObject floor_faces;
    floor_faces.name           = "Chão";
    floor_faces.first_index    = (void*)(36*sizeof(GLuint)); // Começa depois das faces do cubo (índice 36)
    floor_faces.num_indices    = 6; // 2 triângulos = 6 índices
    floor_faces.rendering_mode = GL_TRIANGLES;
    g_VirtualScene["floor"] = floor_faces;

Atualiza o índice inicial (depois das faces do cubo + faces do chão)
cube_edges.first_index    = (void*)((36+6)*sizeof(GLuint)); // Começa em indices[42]

Atualiza o índice inicial (depois do cubo, chão e arestas)
axes.first_index    = (void*)((36+6+24)*sizeof(GLuint)); // Começa em indices[66]

Atualiza ao não pressionar o botão esquerdo
glfwGetCursorPos(window, &g_LastCursorPosX, &g_LastCursorPosY);
return;

